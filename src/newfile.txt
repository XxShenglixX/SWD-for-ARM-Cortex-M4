/** <!For internal use only!>
  * waitIncomingData is a function to waiting data coming from host
  *
  * input     : 
  *
  * return    : NONE
  */
void waitIncomingData(UART_HandleTypeDef *uartHandle, uint8_t *buffer) {
  int received = 0;
  while(HAL_UART_Receive(uartHandle, buffer, sizeof(buffer), 5000) == HAL_OK) {
     break;
  }
}

/** tlvDecodeAndWriteToRam
  *
  * input   :   buffer is a pointer poiniting to an array that contain tlvPacket
  *
  * return  :   1 data is successful write into target ram
  *             0 data fail to write into target ram
  */
int tlvDecodeAndWriteToRam(uint8_t *buffer) {
  int i = 0, verifyStatus = 0;
  
  /* Decode packet from buffer */
  TLV *tlv = (TLV *)buffer;
  uint8_t length = tlv->length - CHECKSUM_LENGTH - ADDRESS_LENGTH;
  uint32_t address = get4Byte(&tlv->value[0]);
  
  verifyStatus = verifyValue(&tlv->value[i + ADDRESS_LENGTH], length);
  
  if(verifyStatus)  {
    /* Write to ram using swd */
    for(i = 0; i < length; i += 4)  {
      /* Data start at position 4 */
      memoryWriteWord(address, get4Byte(&tlv->value[i + ADDRESS_LENGTH]));
      address = address + 4;
    }
      return WRITE_SUCCESS;
  }
  // else  return WRITE_FAIL;
}

/** verifyValue is a function to verify tlv data by adding
  * with the checksum value
  *
  * input     : data is a pointer pointing to TLV structure
  *
  * return    : 1   data is invalid
  *             0   data is valid
  */
int verifyValue(uint8_t *data, uint8_t length) {
  int i = 0;  uint8_t sum = 0;
  
  for(i; i < length + 1; i++) {
    sum += data[i];
  }
  
  if(sum == 0)  return 1;
  
  else  return 0;
}

/** tlvWriteToTargetRam
  *
  * input     : 
  *
  * return    : NONE
  */
void probeProgrammer(Probe_TypeDef *probe)  {
  uint8_t instruction = 0, writeRamStatus = 0;
  uint8_t txBuffer[10];
  uint8_t rxBuffer[10];
  uint8_t *temp;
  uint8_t *buffer = PROBE_OK;

  switch(probe->state) {
    case PROBE_WAIT :
      waitIncomingData(probe->uartHandle, probe->rxBuffer);
      probe->state = PROBE_INTERPRET_INSTRUCTION;
      break;
      
    case PROBE_INTERPRET_INSTRUCTION :
      if(probe->rxBuffer[0] == TLV_START_TRANSMISSION) {
        /* reply host now probe is ready for transmission */
        //stm32UartSendByte(probe->uartHandle, PROBE_OK);
        probe->txBuffer[0] = PROBE_OK;
        HAL_UART_Transmit(probe->uartHandle, probe->txBuffer, 1, 5000);
        probe->rxBuffer[0] = 0;
        probe->state = PROBE_WAIT;
      }
      
      else if(probe->rxBuffer[0] == TLV_WRITE) {
        writeRamStatus = tlvDecodeAndWriteToRam(probe->rxBuffer);
        /* Reply to host probe is ready for next packet */
        // if(writeRamStatus == WRITE_SUCCESS) {
      	  // txBuffer[0] = PROBE_OK;
      	  // HAL_UART_Transmit(probe->uartHandle, txBuffer, sizeof(txBuffer), 5000);
          // probe->rxBuffer[0] = 0;
        // }
        
        // else {
      	  // txBuffer[0] = TLV_DATA_CORRUPTED;
      	  // HAL_UART_Transmit(probe->uartHandle, txBuffer, sizeof(txBuffer), 5000);
          // probe->rxBuffer[0] = 0;
        // }
        // probe->rxBuffer[0] = 0;
        temp = probe->rxBuffer;
        probe->txBuffer[0] = PROBE_OK;  
        HAL_UART_Transmit(probe->uartHandle, probe->txBuffer, 1, 5000);
        probe->rxBuffer[0] = 0;
        probe->state = PROBE_WAIT;
      }
      
      else if(probe->rxBuffer[0] == TLV_END_TRANSMISSION) {
        probe->state = PROBE_END;
        return;
      }
      
      // else {
        // do some error handling here
      // }
      probe->state = PROBE_WAIT;
      break;

    // case PROBE_END :
      // return;
      // break;
  }
}