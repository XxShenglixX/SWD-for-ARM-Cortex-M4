/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "cmock.h"
#include "mock_configurePort.h"

typedef struct _CMOCK_turnOnLED3_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_turnOnLED3_CALL_INSTANCE;

typedef struct _CMOCK_turnOffLED3_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_turnOffLED3_CALL_INSTANCE;

typedef struct _CMOCK_turnOnLED4_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_turnOnLED4_CALL_INSTANCE;

typedef struct _CMOCK_turnOffLED4_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_turnOffLED4_CALL_INSTANCE;

typedef struct _CMOCK_configureClock_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_configureClock_CALL_INSTANCE;

typedef struct _CMOCK_configureTargetResetPin_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_configureTargetResetPin_CALL_INSTANCE;

typedef struct _CMOCK_SWDIO_OutputMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_SWDIO_OutputMode_CALL_INSTANCE;

typedef struct _CMOCK_SWDIO_InputMode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_SWDIO_InputMode_CALL_INSTANCE;

typedef struct _CMOCK_configure_IOPorts_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_configure_IOPorts_CALL_INSTANCE;

typedef struct _CMOCK_configureLED_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_configureLED_CALL_INSTANCE;

typedef struct _CMOCK_initButton_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_initButton_CALL_INSTANCE;

typedef struct _CMOCK_Button_GetState_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint32_t ReturnVal;
  int CallOrder;

} CMOCK_Button_GetState_CALL_INSTANCE;

typedef struct _CMOCK_configureUartPorts_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int CallOrder;

} CMOCK_configureUartPorts_CALL_INSTANCE;

static struct mock_configurePortInstance
{
  int turnOnLED3_IgnoreBool;
  CMOCK_turnOnLED3_CALLBACK turnOnLED3_CallbackFunctionPointer;
  int turnOnLED3_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE turnOnLED3_CallInstance;
  int turnOffLED3_IgnoreBool;
  CMOCK_turnOffLED3_CALLBACK turnOffLED3_CallbackFunctionPointer;
  int turnOffLED3_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE turnOffLED3_CallInstance;
  int turnOnLED4_IgnoreBool;
  CMOCK_turnOnLED4_CALLBACK turnOnLED4_CallbackFunctionPointer;
  int turnOnLED4_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE turnOnLED4_CallInstance;
  int turnOffLED4_IgnoreBool;
  CMOCK_turnOffLED4_CALLBACK turnOffLED4_CallbackFunctionPointer;
  int turnOffLED4_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE turnOffLED4_CallInstance;
  int configureClock_IgnoreBool;
  CMOCK_configureClock_CALLBACK configureClock_CallbackFunctionPointer;
  int configureClock_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE configureClock_CallInstance;
  int configureTargetResetPin_IgnoreBool;
  CMOCK_configureTargetResetPin_CALLBACK configureTargetResetPin_CallbackFunctionPointer;
  int configureTargetResetPin_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE configureTargetResetPin_CallInstance;
  int SWDIO_OutputMode_IgnoreBool;
  CMOCK_SWDIO_OutputMode_CALLBACK SWDIO_OutputMode_CallbackFunctionPointer;
  int SWDIO_OutputMode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE SWDIO_OutputMode_CallInstance;
  int SWDIO_InputMode_IgnoreBool;
  CMOCK_SWDIO_InputMode_CALLBACK SWDIO_InputMode_CallbackFunctionPointer;
  int SWDIO_InputMode_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE SWDIO_InputMode_CallInstance;
  int configure_IOPorts_IgnoreBool;
  CMOCK_configure_IOPorts_CALLBACK configure_IOPorts_CallbackFunctionPointer;
  int configure_IOPorts_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE configure_IOPorts_CallInstance;
  int configureLED_IgnoreBool;
  CMOCK_configureLED_CALLBACK configureLED_CallbackFunctionPointer;
  int configureLED_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE configureLED_CallInstance;
  int initButton_IgnoreBool;
  CMOCK_initButton_CALLBACK initButton_CallbackFunctionPointer;
  int initButton_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE initButton_CallInstance;
  int Button_GetState_IgnoreBool;
  uint32_t Button_GetState_FinalReturn;
  CMOCK_Button_GetState_CALLBACK Button_GetState_CallbackFunctionPointer;
  int Button_GetState_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE Button_GetState_CallInstance;
  int configureUartPorts_IgnoreBool;
  CMOCK_configureUartPorts_CALLBACK configureUartPorts_CallbackFunctionPointer;
  int configureUartPorts_CallbackCalls;
  CMOCK_MEM_INDEX_TYPE configureUartPorts_CallInstance;
} Mock;

extern jmp_buf AbortFrame;
extern int GlobalExpectCount;
extern int GlobalVerifyOrder;

void mock_configurePort_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  if (Mock.turnOnLED3_IgnoreBool)
    Mock.turnOnLED3_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.turnOnLED3_CallInstance, cmock_line, "Function 'turnOnLED3' called less times than expected.");
  if (Mock.turnOnLED3_CallbackFunctionPointer != NULL)
    Mock.turnOnLED3_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.turnOffLED3_IgnoreBool)
    Mock.turnOffLED3_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.turnOffLED3_CallInstance, cmock_line, "Function 'turnOffLED3' called less times than expected.");
  if (Mock.turnOffLED3_CallbackFunctionPointer != NULL)
    Mock.turnOffLED3_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.turnOnLED4_IgnoreBool)
    Mock.turnOnLED4_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.turnOnLED4_CallInstance, cmock_line, "Function 'turnOnLED4' called less times than expected.");
  if (Mock.turnOnLED4_CallbackFunctionPointer != NULL)
    Mock.turnOnLED4_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.turnOffLED4_IgnoreBool)
    Mock.turnOffLED4_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.turnOffLED4_CallInstance, cmock_line, "Function 'turnOffLED4' called less times than expected.");
  if (Mock.turnOffLED4_CallbackFunctionPointer != NULL)
    Mock.turnOffLED4_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.configureClock_IgnoreBool)
    Mock.configureClock_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.configureClock_CallInstance, cmock_line, "Function 'configureClock' called less times than expected.");
  if (Mock.configureClock_CallbackFunctionPointer != NULL)
    Mock.configureClock_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.configureTargetResetPin_IgnoreBool)
    Mock.configureTargetResetPin_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.configureTargetResetPin_CallInstance, cmock_line, "Function 'configureTargetResetPin' called less times than expected.");
  if (Mock.configureTargetResetPin_CallbackFunctionPointer != NULL)
    Mock.configureTargetResetPin_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.SWDIO_OutputMode_IgnoreBool)
    Mock.SWDIO_OutputMode_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.SWDIO_OutputMode_CallInstance, cmock_line, "Function 'SWDIO_OutputMode' called less times than expected.");
  if (Mock.SWDIO_OutputMode_CallbackFunctionPointer != NULL)
    Mock.SWDIO_OutputMode_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.SWDIO_InputMode_IgnoreBool)
    Mock.SWDIO_InputMode_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.SWDIO_InputMode_CallInstance, cmock_line, "Function 'SWDIO_InputMode' called less times than expected.");
  if (Mock.SWDIO_InputMode_CallbackFunctionPointer != NULL)
    Mock.SWDIO_InputMode_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.configure_IOPorts_IgnoreBool)
    Mock.configure_IOPorts_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.configure_IOPorts_CallInstance, cmock_line, "Function 'configure_IOPorts' called less times than expected.");
  if (Mock.configure_IOPorts_CallbackFunctionPointer != NULL)
    Mock.configure_IOPorts_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.configureLED_IgnoreBool)
    Mock.configureLED_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.configureLED_CallInstance, cmock_line, "Function 'configureLED' called less times than expected.");
  if (Mock.configureLED_CallbackFunctionPointer != NULL)
    Mock.configureLED_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.initButton_IgnoreBool)
    Mock.initButton_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.initButton_CallInstance, cmock_line, "Function 'initButton' called less times than expected.");
  if (Mock.initButton_CallbackFunctionPointer != NULL)
    Mock.initButton_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.Button_GetState_IgnoreBool)
    Mock.Button_GetState_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.Button_GetState_CallInstance, cmock_line, "Function 'Button_GetState' called less times than expected.");
  if (Mock.Button_GetState_CallbackFunctionPointer != NULL)
    Mock.Button_GetState_CallInstance = CMOCK_GUTS_NONE;
  if (Mock.configureUartPorts_IgnoreBool)
    Mock.configureUartPorts_CallInstance = CMOCK_GUTS_NONE;
  UNITY_TEST_ASSERT(CMOCK_GUTS_NONE == Mock.configureUartPorts_CallInstance, cmock_line, "Function 'configureUartPorts' called less times than expected.");
  if (Mock.configureUartPorts_CallbackFunctionPointer != NULL)
    Mock.configureUartPorts_CallInstance = CMOCK_GUTS_NONE;
}

void mock_configurePort_Init(void)
{
  mock_configurePort_Destroy();
}

void mock_configurePort_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
  Mock.turnOnLED3_CallbackFunctionPointer = NULL;
  Mock.turnOnLED3_CallbackCalls = 0;
  Mock.turnOffLED3_CallbackFunctionPointer = NULL;
  Mock.turnOffLED3_CallbackCalls = 0;
  Mock.turnOnLED4_CallbackFunctionPointer = NULL;
  Mock.turnOnLED4_CallbackCalls = 0;
  Mock.turnOffLED4_CallbackFunctionPointer = NULL;
  Mock.turnOffLED4_CallbackCalls = 0;
  Mock.configureClock_CallbackFunctionPointer = NULL;
  Mock.configureClock_CallbackCalls = 0;
  Mock.configureTargetResetPin_CallbackFunctionPointer = NULL;
  Mock.configureTargetResetPin_CallbackCalls = 0;
  Mock.SWDIO_OutputMode_CallbackFunctionPointer = NULL;
  Mock.SWDIO_OutputMode_CallbackCalls = 0;
  Mock.SWDIO_InputMode_CallbackFunctionPointer = NULL;
  Mock.SWDIO_InputMode_CallbackCalls = 0;
  Mock.configure_IOPorts_CallbackFunctionPointer = NULL;
  Mock.configure_IOPorts_CallbackCalls = 0;
  Mock.configureLED_CallbackFunctionPointer = NULL;
  Mock.configureLED_CallbackCalls = 0;
  Mock.initButton_CallbackFunctionPointer = NULL;
  Mock.initButton_CallbackCalls = 0;
  Mock.Button_GetState_CallbackFunctionPointer = NULL;
  Mock.Button_GetState_CallbackCalls = 0;
  Mock.configureUartPorts_CallbackFunctionPointer = NULL;
  Mock.configureUartPorts_CallbackCalls = 0;
  GlobalExpectCount = 0;
  GlobalVerifyOrder = 0;
}

void turnOnLED3(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turnOnLED3_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOnLED3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turnOnLED3_CallInstance);
  Mock.turnOnLED3_CallInstance = CMock_Guts_MemNext(Mock.turnOnLED3_CallInstance);
  if (Mock.turnOnLED3_IgnoreBool)
  {
    return;
  }
  if (Mock.turnOnLED3_CallbackFunctionPointer != NULL)
  {
    Mock.turnOnLED3_CallbackFunctionPointer(Mock.turnOnLED3_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'turnOnLED3' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOnLED3' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOnLED3' called later than expected.");
}

void turnOnLED3_CMockIgnore(void)
{
  Mock.turnOnLED3_IgnoreBool = (int)1;
}

void turnOnLED3_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turnOnLED3_CALL_INSTANCE));
  CMOCK_turnOnLED3_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOnLED3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turnOnLED3_CallInstance = CMock_Guts_MemChain(Mock.turnOnLED3_CallInstance, cmock_guts_index);
  Mock.turnOnLED3_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void turnOnLED3_StubWithCallback(CMOCK_turnOnLED3_CALLBACK Callback)
{
  Mock.turnOnLED3_CallbackFunctionPointer = Callback;
}

void turnOffLED3(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turnOffLED3_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOffLED3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turnOffLED3_CallInstance);
  Mock.turnOffLED3_CallInstance = CMock_Guts_MemNext(Mock.turnOffLED3_CallInstance);
  if (Mock.turnOffLED3_IgnoreBool)
  {
    return;
  }
  if (Mock.turnOffLED3_CallbackFunctionPointer != NULL)
  {
    Mock.turnOffLED3_CallbackFunctionPointer(Mock.turnOffLED3_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'turnOffLED3' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOffLED3' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOffLED3' called later than expected.");
}

void turnOffLED3_CMockIgnore(void)
{
  Mock.turnOffLED3_IgnoreBool = (int)1;
}

void turnOffLED3_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turnOffLED3_CALL_INSTANCE));
  CMOCK_turnOffLED3_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOffLED3_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turnOffLED3_CallInstance = CMock_Guts_MemChain(Mock.turnOffLED3_CallInstance, cmock_guts_index);
  Mock.turnOffLED3_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void turnOffLED3_StubWithCallback(CMOCK_turnOffLED3_CALLBACK Callback)
{
  Mock.turnOffLED3_CallbackFunctionPointer = Callback;
}

void turnOnLED4(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turnOnLED4_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOnLED4_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turnOnLED4_CallInstance);
  Mock.turnOnLED4_CallInstance = CMock_Guts_MemNext(Mock.turnOnLED4_CallInstance);
  if (Mock.turnOnLED4_IgnoreBool)
  {
    return;
  }
  if (Mock.turnOnLED4_CallbackFunctionPointer != NULL)
  {
    Mock.turnOnLED4_CallbackFunctionPointer(Mock.turnOnLED4_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'turnOnLED4' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOnLED4' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOnLED4' called later than expected.");
}

void turnOnLED4_CMockIgnore(void)
{
  Mock.turnOnLED4_IgnoreBool = (int)1;
}

void turnOnLED4_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turnOnLED4_CALL_INSTANCE));
  CMOCK_turnOnLED4_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOnLED4_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turnOnLED4_CallInstance = CMock_Guts_MemChain(Mock.turnOnLED4_CallInstance, cmock_guts_index);
  Mock.turnOnLED4_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void turnOnLED4_StubWithCallback(CMOCK_turnOnLED4_CALLBACK Callback)
{
  Mock.turnOnLED4_CallbackFunctionPointer = Callback;
}

void turnOffLED4(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_turnOffLED4_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOffLED4_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.turnOffLED4_CallInstance);
  Mock.turnOffLED4_CallInstance = CMock_Guts_MemNext(Mock.turnOffLED4_CallInstance);
  if (Mock.turnOffLED4_IgnoreBool)
  {
    return;
  }
  if (Mock.turnOffLED4_CallbackFunctionPointer != NULL)
  {
    Mock.turnOffLED4_CallbackFunctionPointer(Mock.turnOffLED4_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'turnOffLED4' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOffLED4' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'turnOffLED4' called later than expected.");
}

void turnOffLED4_CMockIgnore(void)
{
  Mock.turnOffLED4_IgnoreBool = (int)1;
}

void turnOffLED4_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_turnOffLED4_CALL_INSTANCE));
  CMOCK_turnOffLED4_CALL_INSTANCE* cmock_call_instance = (CMOCK_turnOffLED4_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.turnOffLED4_CallInstance = CMock_Guts_MemChain(Mock.turnOffLED4_CallInstance, cmock_guts_index);
  Mock.turnOffLED4_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void turnOffLED4_StubWithCallback(CMOCK_turnOffLED4_CALLBACK Callback)
{
  Mock.turnOffLED4_CallbackFunctionPointer = Callback;
}

void configureClock(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_configureClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.configureClock_CallInstance);
  Mock.configureClock_CallInstance = CMock_Guts_MemNext(Mock.configureClock_CallInstance);
  if (Mock.configureClock_IgnoreBool)
  {
    return;
  }
  if (Mock.configureClock_CallbackFunctionPointer != NULL)
  {
    Mock.configureClock_CallbackFunctionPointer(Mock.configureClock_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'configureClock' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureClock' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureClock' called later than expected.");
}

void configureClock_CMockIgnore(void)
{
  Mock.configureClock_IgnoreBool = (int)1;
}

void configureClock_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_configureClock_CALL_INSTANCE));
  CMOCK_configureClock_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureClock_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.configureClock_CallInstance = CMock_Guts_MemChain(Mock.configureClock_CallInstance, cmock_guts_index);
  Mock.configureClock_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void configureClock_StubWithCallback(CMOCK_configureClock_CALLBACK Callback)
{
  Mock.configureClock_CallbackFunctionPointer = Callback;
}

void configureTargetResetPin(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_configureTargetResetPin_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureTargetResetPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.configureTargetResetPin_CallInstance);
  Mock.configureTargetResetPin_CallInstance = CMock_Guts_MemNext(Mock.configureTargetResetPin_CallInstance);
  if (Mock.configureTargetResetPin_IgnoreBool)
  {
    return;
  }
  if (Mock.configureTargetResetPin_CallbackFunctionPointer != NULL)
  {
    Mock.configureTargetResetPin_CallbackFunctionPointer(Mock.configureTargetResetPin_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'configureTargetResetPin' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureTargetResetPin' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureTargetResetPin' called later than expected.");
}

void configureTargetResetPin_CMockIgnore(void)
{
  Mock.configureTargetResetPin_IgnoreBool = (int)1;
}

void configureTargetResetPin_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_configureTargetResetPin_CALL_INSTANCE));
  CMOCK_configureTargetResetPin_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureTargetResetPin_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.configureTargetResetPin_CallInstance = CMock_Guts_MemChain(Mock.configureTargetResetPin_CallInstance, cmock_guts_index);
  Mock.configureTargetResetPin_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void configureTargetResetPin_StubWithCallback(CMOCK_configureTargetResetPin_CALLBACK Callback)
{
  Mock.configureTargetResetPin_CallbackFunctionPointer = Callback;
}

void SWDIO_OutputMode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SWDIO_OutputMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SWDIO_OutputMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SWDIO_OutputMode_CallInstance);
  Mock.SWDIO_OutputMode_CallInstance = CMock_Guts_MemNext(Mock.SWDIO_OutputMode_CallInstance);
  if (Mock.SWDIO_OutputMode_IgnoreBool)
  {
    return;
  }
  if (Mock.SWDIO_OutputMode_CallbackFunctionPointer != NULL)
  {
    Mock.SWDIO_OutputMode_CallbackFunctionPointer(Mock.SWDIO_OutputMode_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'SWDIO_OutputMode' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'SWDIO_OutputMode' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'SWDIO_OutputMode' called later than expected.");
}

void SWDIO_OutputMode_CMockIgnore(void)
{
  Mock.SWDIO_OutputMode_IgnoreBool = (int)1;
}

void SWDIO_OutputMode_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SWDIO_OutputMode_CALL_INSTANCE));
  CMOCK_SWDIO_OutputMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SWDIO_OutputMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SWDIO_OutputMode_CallInstance = CMock_Guts_MemChain(Mock.SWDIO_OutputMode_CallInstance, cmock_guts_index);
  Mock.SWDIO_OutputMode_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void SWDIO_OutputMode_StubWithCallback(CMOCK_SWDIO_OutputMode_CALLBACK Callback)
{
  Mock.SWDIO_OutputMode_CallbackFunctionPointer = Callback;
}

void SWDIO_InputMode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_SWDIO_InputMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SWDIO_InputMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.SWDIO_InputMode_CallInstance);
  Mock.SWDIO_InputMode_CallInstance = CMock_Guts_MemNext(Mock.SWDIO_InputMode_CallInstance);
  if (Mock.SWDIO_InputMode_IgnoreBool)
  {
    return;
  }
  if (Mock.SWDIO_InputMode_CallbackFunctionPointer != NULL)
  {
    Mock.SWDIO_InputMode_CallbackFunctionPointer(Mock.SWDIO_InputMode_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'SWDIO_InputMode' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'SWDIO_InputMode' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'SWDIO_InputMode' called later than expected.");
}

void SWDIO_InputMode_CMockIgnore(void)
{
  Mock.SWDIO_InputMode_IgnoreBool = (int)1;
}

void SWDIO_InputMode_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_SWDIO_InputMode_CALL_INSTANCE));
  CMOCK_SWDIO_InputMode_CALL_INSTANCE* cmock_call_instance = (CMOCK_SWDIO_InputMode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.SWDIO_InputMode_CallInstance = CMock_Guts_MemChain(Mock.SWDIO_InputMode_CallInstance, cmock_guts_index);
  Mock.SWDIO_InputMode_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void SWDIO_InputMode_StubWithCallback(CMOCK_SWDIO_InputMode_CALLBACK Callback)
{
  Mock.SWDIO_InputMode_CallbackFunctionPointer = Callback;
}

void configure_IOPorts(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_configure_IOPorts_CALL_INSTANCE* cmock_call_instance = (CMOCK_configure_IOPorts_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.configure_IOPorts_CallInstance);
  Mock.configure_IOPorts_CallInstance = CMock_Guts_MemNext(Mock.configure_IOPorts_CallInstance);
  if (Mock.configure_IOPorts_IgnoreBool)
  {
    return;
  }
  if (Mock.configure_IOPorts_CallbackFunctionPointer != NULL)
  {
    Mock.configure_IOPorts_CallbackFunctionPointer(Mock.configure_IOPorts_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'configure_IOPorts' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configure_IOPorts' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configure_IOPorts' called later than expected.");
}

void configure_IOPorts_CMockIgnore(void)
{
  Mock.configure_IOPorts_IgnoreBool = (int)1;
}

void configure_IOPorts_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_configure_IOPorts_CALL_INSTANCE));
  CMOCK_configure_IOPorts_CALL_INSTANCE* cmock_call_instance = (CMOCK_configure_IOPorts_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.configure_IOPorts_CallInstance = CMock_Guts_MemChain(Mock.configure_IOPorts_CallInstance, cmock_guts_index);
  Mock.configure_IOPorts_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void configure_IOPorts_StubWithCallback(CMOCK_configure_IOPorts_CALLBACK Callback)
{
  Mock.configure_IOPorts_CallbackFunctionPointer = Callback;
}

void configureLED(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_configureLED_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureLED_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.configureLED_CallInstance);
  Mock.configureLED_CallInstance = CMock_Guts_MemNext(Mock.configureLED_CallInstance);
  if (Mock.configureLED_IgnoreBool)
  {
    return;
  }
  if (Mock.configureLED_CallbackFunctionPointer != NULL)
  {
    Mock.configureLED_CallbackFunctionPointer(Mock.configureLED_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'configureLED' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureLED' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureLED' called later than expected.");
}

void configureLED_CMockIgnore(void)
{
  Mock.configureLED_IgnoreBool = (int)1;
}

void configureLED_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_configureLED_CALL_INSTANCE));
  CMOCK_configureLED_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureLED_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.configureLED_CallInstance = CMock_Guts_MemChain(Mock.configureLED_CallInstance, cmock_guts_index);
  Mock.configureLED_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void configureLED_StubWithCallback(CMOCK_configureLED_CALLBACK Callback)
{
  Mock.configureLED_CallbackFunctionPointer = Callback;
}

void initButton(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_initButton_CALL_INSTANCE* cmock_call_instance = (CMOCK_initButton_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.initButton_CallInstance);
  Mock.initButton_CallInstance = CMock_Guts_MemNext(Mock.initButton_CallInstance);
  if (Mock.initButton_IgnoreBool)
  {
    return;
  }
  if (Mock.initButton_CallbackFunctionPointer != NULL)
  {
    Mock.initButton_CallbackFunctionPointer(Mock.initButton_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'initButton' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'initButton' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'initButton' called later than expected.");
}

void initButton_CMockIgnore(void)
{
  Mock.initButton_IgnoreBool = (int)1;
}

void initButton_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_initButton_CALL_INSTANCE));
  CMOCK_initButton_CALL_INSTANCE* cmock_call_instance = (CMOCK_initButton_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.initButton_CallInstance = CMock_Guts_MemChain(Mock.initButton_CallInstance, cmock_guts_index);
  Mock.initButton_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void initButton_StubWithCallback(CMOCK_initButton_CALLBACK Callback)
{
  Mock.initButton_CallbackFunctionPointer = Callback;
}

uint32_t Button_GetState(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_Button_GetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_Button_GetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.Button_GetState_CallInstance);
  Mock.Button_GetState_CallInstance = CMock_Guts_MemNext(Mock.Button_GetState_CallInstance);
  if (Mock.Button_GetState_IgnoreBool)
  {
    if (cmock_call_instance == NULL)
      return (uint32_t)Mock.Button_GetState_FinalReturn;
    Mock.Button_GetState_FinalReturn = cmock_call_instance->ReturnVal;
    return (uint32_t)cmock_call_instance->ReturnVal;
  }
  if (Mock.Button_GetState_CallbackFunctionPointer != NULL)
  {
    return Mock.Button_GetState_CallbackFunctionPointer(Mock.Button_GetState_CallbackCalls++);
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'Button_GetState' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'Button_GetState' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'Button_GetState' called later than expected.");
  return cmock_call_instance->ReturnVal;
}

void Button_GetState_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_Button_GetState_CALL_INSTANCE));
  CMOCK_Button_GetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_Button_GetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.Button_GetState_CallInstance = CMock_Guts_MemChain(Mock.Button_GetState_CallInstance, cmock_guts_index);
  Mock.Button_GetState_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.Button_GetState_IgnoreBool = (int)1;
}

void Button_GetState_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint32_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_Button_GetState_CALL_INSTANCE));
  CMOCK_Button_GetState_CALL_INSTANCE* cmock_call_instance = (CMOCK_Button_GetState_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.Button_GetState_CallInstance = CMock_Guts_MemChain(Mock.Button_GetState_CallInstance, cmock_guts_index);
  Mock.Button_GetState_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void Button_GetState_StubWithCallback(CMOCK_Button_GetState_CALLBACK Callback)
{
  Mock.Button_GetState_CallbackFunctionPointer = Callback;
}

void configureUartPorts(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_configureUartPorts_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureUartPorts_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.configureUartPorts_CallInstance);
  Mock.configureUartPorts_CallInstance = CMock_Guts_MemNext(Mock.configureUartPorts_CallInstance);
  if (Mock.configureUartPorts_IgnoreBool)
  {
    return;
  }
  if (Mock.configureUartPorts_CallbackFunctionPointer != NULL)
  {
    Mock.configureUartPorts_CallbackFunctionPointer(Mock.configureUartPorts_CallbackCalls++);
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "Function 'configureUartPorts' called more times than expected.");
  cmock_line = cmock_call_instance->LineNumber;
  if (cmock_call_instance->CallOrder > ++GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureUartPorts' called earlier than expected.");
  if (cmock_call_instance->CallOrder < GlobalVerifyOrder)
    UNITY_TEST_FAIL(cmock_line, "Function 'configureUartPorts' called later than expected.");
}

void configureUartPorts_CMockIgnore(void)
{
  Mock.configureUartPorts_IgnoreBool = (int)1;
}

void configureUartPorts_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_configureUartPorts_CALL_INSTANCE));
  CMOCK_configureUartPorts_CALL_INSTANCE* cmock_call_instance = (CMOCK_configureUartPorts_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, "CMock has run out of memory. Please allocate more.");
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.configureUartPorts_CallInstance = CMock_Guts_MemChain(Mock.configureUartPorts_CallInstance, cmock_guts_index);
  Mock.configureUartPorts_IgnoreBool = (int)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->CallOrder = ++GlobalExpectCount;
}

void configureUartPorts_StubWithCallback(CMOCK_configureUartPorts_CALLBACK Callback)
{
  Mock.configureUartPorts_CallbackFunctionPointer = Callback;
}

